# Table of Contents

* [java性能调优概述](#java性能调优概述)
* [设计优化](#设计优化)
* [java程序优化](#java程序优化)
* [并行程序开发优化](#并行程序开发优化)
  * [并行程序设计模式](#并行程序设计模式)
  * [JDK多任务执行框架](#jdk多任务执行框架)
  * [JDK并发数据结构](#jdk并发数据结构)
  * [并发控制方法](#并发控制方法)
* [JVM调优](#jvm调优)
  * [JVM 内存模型](#jvm-内存模型)
  * [JVM内存分配参数](#jvm内存分配参数)
  * [垃圾收集](#垃圾收集)
    * [垃圾收集器要处理的基本问题：](#垃圾收集器要处理的基本问题：)
    * [算法：](#算法：)
    * [垃圾收集器的类型](#垃圾收集器的类型)
    * [评价GC策略的指标：](#评价gc策略的指标：)
* [性能调优工具](#性能调优工具)
  * [Linux命令行](#linux命令行)
  * [Windows工具](#windows工具)
  * [JDK命令行](#jdk命令行)
* [参考资料](#参考资料)



# java性能调优概述

一般来说，程序的性能的表现方面：

- 执行速度
- 内存分配
- 启动时间
- 负载承受能力

性能参考指标：

- 执行时间
- CPU时间
- 内存分配
- 磁盘吞吐量
- 网络吞吐量
- 响应时间

木桶原理与性能瓶颈，最有可能成为性能瓶颈的环节：

- 磁盘IO
- 网络操作
- CPU
- 异常
- 数据库
- 锁竞争
- 内存

加速比=优化前系统耗时/优化后系统耗时
**Amdahl定律**：
加速比speedup<=1/(F+(1-F)/N)

其中N为CPU处理器数量，F为系统内必须串行化的程序比重。由此可见，为了提高系统的运行速度，仅仅增加N，是不能提高运行速度的，从根本上修改程序的串行化行为，提高系统内并行模块的占比，才行。

**性能调优层次**：

设计调优

代码调优

JVM调优

数据库调优：1. 应用层SQL优化；2.数据库优化；3.数据库软件优化；

操作系统调优：共享内存段、信号量、共享内存最大值shmmax、共享内存最小值shmmin、最大文件句柄数、虚拟内存大小、磁盘块大小。

**一,JAVA性能优化之设计优化** 

设计优化处于性能优化手段的上层。它往往须要在软件开发之前进行。在软件开发之前，系统架构师应该就评估系统可能存在的各种潜在问题和技术难点，并给出合理的设计方案，因为软件设计和系统架构对软件总体设计质量有决定性的影响。所以，设计调优对系统的性能影响也是最大的，假设说，代码优化。JVM优化都是对系统微观层次的“量”的优化，那设计优化就是对系统”质”的优化. 
设计优化的一大显著特征是:它能够规避某一个组件的性能问题,而是改良组件的实现;比方:组件A通过循环监控不断的检測时间E是否发生,其检測行为必定会占用部分系统资源,因此,开发者必须检測频率和资源消耗上取得平衡,假设检測频率太低,尽管降低了资源消耗,可是系统实时反应性就会降低,假设进行代码层的调优,就须要优化检測方法的实现及要求得一个最为恰当的检測频率.对于这个问题我们就能够用设计模式中的观察者模式 ,当事件E发生的时刻,由事件E通知组件A,从而触发组件A的行为.这样的设计从根本上攻克了存在性能隐患的循环监控,从根本上攻克了这一问题. 
**进行设计优化时,设计人员和必须熟悉经常使用的设计方法,设计模式,以及主要的性能组件和经常使用的优化思想,并将其有机地集成在软件系统中.** 
*注意:一个良好的系统设计能够规避非常多潜在在的性能问题.因此,尽可能多花些时间在系统设计上,是创建高性能程序的关键* 

**二,JAVA性能优化之代码优化** 

代码调优是在软件开发中,或者是软件开发完毕后,软件维护过程中进行的程序代码的改进和优化.代码优化涉及诸多编码技巧,须要开发者熟悉相关的语言API ,并在适合的场景中正确的使用相关API或类库.同一时候,对算法,数据结构的灵活使用,也是代码优化的一个重要内容. 
尽管代码优化时从微观上对性能进行调整,可是一个”好”的实现和一个”坏”的实现对系统的影响也是非常大的.比方,相同作为List的实现,LinkedList和ArrayList在随机訪问上的性能却差了好几个量级;比方相同是文件读写的实现,使用Stream方式和使用JAVA NIO的方式,其系能可能又会是还有一个数量级. 
因此,尽管与设计优化相比,笔者将代码优化成为在微观层面上的优化,但它却是对系统性能产生最直接影响的优化方法. 

**三,JVM优化** 

因为JAVA软件总是执行在JVM虚拟机之上。对JVM虚拟机进行优化也能一定程度上的提升JAVA程序的性能。JVM通常能够在软件开发后期进行，如在开发完毕或者是软件开发的某一里程碑阶段。 
作为JAVA软件的执行平台。JVM的各项參数将会直接影响JAVA程序的性能。

比方，**JVM的堆大小，垃圾回收策略**等等。 
要进行JVM层面的调优。须要开发者对JVM的执行原理和基本内存结构有一定的了解。如，堆内存的结构，GC的种类等。然后，根据引用程序的特点。设置合理的JVM启动參数。

**四。数据库优化** 

对绝大部分应用系统而言。数据库是不可缺少的一部分。JAVA程序能够使用JDBC的方式连接数据库。对数据库的调优能够分为三个部分：

- **在应用层对SQL语句进行优化；**
- **对数据库进行优化。**
- 对数据库软件进行优化。

在应用层优化数据库訪问。涉及大量的编程技巧。比方。当使用JDBC进行查询的时候，对于大量拥有相同结构的SQL查询，能够使用PerparedStatement取代Statement。以提高数据库的查询效率。在使用Select语句中，显示指定要查询的列名 ，避免使用* 
在对数据库优化时，主要目的是建立一个具有良好表结构的数据库。

比方，为了提高多表级联查询的效率，能够合理地使用冗余字段；对于大表，能够使用行的水平分割或者相似Oracle分区的技术；为了提高数据的查询的效率，能够建立有效水平分割或者相似Oracle分区表的技术；为了提高数据库查询效率。在select语句中。显示指定要查询的列名，避免使用*。 
在对数据库进行优化时。主要目的是建立一个具有良好表结构的数据库。比方，为了提高多表级联查询效率，能够合理地使用冗余字段。对于大表。能够使用行数据来水平分割，为了提高数据库的查询效率，能够建立有效且事宜的索引 

**五，JAVA性能优化之操作系统优化** 

操作系统，调优的手段和參数可能有所不同，比方，在主流Unix系统中。共享内存段。信号量，共享内存最大值（shmmax）。共享内存最小值（shmmin）等都是能够进行优化的系统资源.此外,如最大文件句柄数,虚拟内存大小,磁盘的块大小等參数都可能对软件的性能产生影响.配置虚拟内存界面![这里写图片描写叙述](http://img.blog.csdn.net/20151211103629980)

# 设计优化

常用手段

1、**善用设计模式**

2、**常用的优化组件和方法**

**缓冲buffer**，减轻数据库或者磁盘**读**的压力；

**缓存cache**，减轻数据库或者磁盘**写**的压力

**对象复用-池：**线程池，数据库连接池；适用场景：创建耗时的大对象，节省获取对象实例的成本，减少GC负担；生成实例成本小的对象，使用池的方式，得不偿失；

**并行代替串行**

**负载均衡**，Apache+Tomcat集群搭建负载均衡解决方案，Session共享模式，黏性Session模式和复制Session模式；跨JVM分布式缓存框架Terracotta，可以实现Tomcat的Session共享；

**时间换空间**，看系统的性能瓶颈是什么，空间是瓶颈，则采用时间换空间；

**空间换时间**

# java程序优化

**字符串优化处理**

**核心数据结构**

**使用NIO**

**引用类型**
	强引用
	软引用
	弱引用
	虚引用

# 并行程序开发优化

## 并行程序设计模式

Future模式，即异步；

master-worker模式，类似于fork-join，master进程负责接收和分配任务，worker进程负责处理子任务；

Guarded Suspension模式，
不变模式，不变模式比只读属性具有更强的一致性和不变性，只读属性自身可能变化；不变模式的使用条件：1. 对象创建后，其内部状态和数据不再发生变化；2. 对象需要被共享，被多线程频繁访问。实现4要点：1. 去掉setter方法和所有修改自身属性的方法；2. 所有属性私有且final；3. 没有子类可以继承并重写其方法；4. 构造函数可以创建完整对象。

生产者-消费者模式；

## JDK多任务执行框架

无限制线程的缺陷

简单的线程池实现

Executor框架

自定义线程池

优化线程池大小，估算公式：N = Nc * Uc * (1+W/C)，其中Nc是CPU的数量，Uc是CPU的使用率，W/C是等待时间与计算时间的比率。

扩展ThreadPoolExecutor

## JDK并发数据结构

并发List
并发Set
并发Map
并发Queue
并发Deque

## 并发控制方法

锁性能与优化
无锁并行计算
协程

# JVM调优

## JVM 内存模型

程序计数器
java虚拟机栈
本地方法栈
java堆
方法区

## JVM内存分配参数

最大堆内存
最小堆内存
新生代
持久代
线程栈
堆的比例分配

## 垃圾收集

### 垃圾收集器要处理的基本问题：

哪些对象需要回收？
何时回收这些对象？
怎么回收这些对象？

### 算法：

引用计数法（reference counting）：问题：循环引用；
标记清除算法（mark-sweep），问题：空间碎片，尤其是大对象的内存分配，不连续的内存空间的工作效率要低于连续的空间。
复制（copy），代价：内存折半；其高效性建立在存活对象少、垃圾对象多的情况。
标记压缩（mark-compact），将所有的存活对象压缩到内存的另一侧；
增量（incremental collecting），垃圾回收时，stw，所有线程挂起；故，垃圾回收与应用程序交替执行；但是线程切换和上下文转换的消耗，使得GC的成本提高，吞吐量下降。
分代（generational collecting）

### 垃圾收集器的类型

按线程数分，串行GC和并行GC；
工作模式分，并发式和独占式；
碎片处理方式分，压缩和非压缩；
工作的内存区间分，新生代和老年代；

### 评价GC策略的指标：

吞吐量
垃圾回收器负载
停顿时间
垃圾回收频率
反应时间
堆分配
新生代串行收集器

# 性能调优工具

## Linux命令行

top
sar
vmstat
iostat
pidstat

## Windows工具

任务管理器
perfmon性能监控工具
process explorer
pslist

## JDK命令行

jps
jstat
jmap
jstack
jinfo
jhat
jstatd
hprof
JConsole
Visual VM多合一工具
Visual VM对OQL的支持
MAT内存分析工具
MAT对OQL的支持
JProfile

# 参考资料

[《Java程序性能优化》读书笔记](<https://blog.csdn.net/lonelymanontheway/article/details/82818512>)

[JAVA性能优化的五种方式](https://www.cnblogs.com/blfbuaa/p/7071612.html)
